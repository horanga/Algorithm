설계
=============
1.돌 수 있는 던전의 조합을 찾아야 한다. 이를 위해서 재귀 방식을 이용했다. 

A(40), B(50), C(20), D(10) 던전이 있고 전체 피로도가 90이라고 해보자. A를 돌면 500이 남고, 
B를 추가로 돌면 0이 된다. 던전은 2개를 돌았다. 만약, B를 건너띄고 A-C-D 던전을 돌았다면 총 3개의 던전수를 돈 것이다.

for문과 재귀함수를 이용하면 이러한 조합을 모두 구할 수 있다. 

우선, 던전에서 소모되는 피로도가 전체 피로도보다 낮은 곳만 돌도록 조건을 설정한다. 이미 돌은 던전은 visited[i]라는 불리언 배열로 '이미 간 곳'이라고 true표시를 해준다. 재귀함수를 시작할 때 true표시가 돼 있는 곳은 자동으로 건너띈다.

```java
 public void combination(int[][] dungeons, int k, int depth) {
        for (int i = 0; i < dungeons.length; i++) {
            if (!visited[i] && k >= dungeons[i][0]) {
                visited[i] = true;
                combination(dungeons, k - dungeons[i][1], depth + 1);
                visited[i] = false;
            }
        }
        count=Math.max(count, depth);
        }

 ```
 
 2.재귀함수의 원리는 이렇다. A를 먼저 갔다고 해보자. 그럼 A는 이미 간 던전으로 표시가 된다. 그리고, 재귀함수를 호출해서 A를 간 상태에서 B/C/D를 고르게 된다. AB에서 다시 재귀함수가 호출돼서 C랑 D 중 하나를, AC에서 다시 재귀함수가 호출돼서 BD중 하나를, AD에서 재귀함수가 호출돼서 B/C 중 하나를 선택하게 된다. 이렇게 모든 조합을 찾아낸다고 생각하면 된다. 대신, 피로도를 매번 체크하고, 한번씩 던전을 돌 때마다 depth를 1씩 추가해주는 로직도 필요하다.
