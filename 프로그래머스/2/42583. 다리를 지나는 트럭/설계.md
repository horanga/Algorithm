설계
=============
1.자료구조는 queue를 썼다. 먼저 들어간 트럭이 먼저 나올 수 있도록 설계하기 위해서다. bridge라는 queue를 만들고, 지문에 나온 다리 길이만큼 0을 채웠다. 

```java
  for (int i =0; i<bridge_length; i++){
            bridge.add(0);
        }
```

다리 길이가 4라고 한다면

0 0 0 0

위처럼 트럭이 들어갈 공간이 4개 생긴다. 

2.다리에 올라간 트럭의 무게 합이 weight를 넘지 않을때까지, 트럭이 다리 위에 올라갈 수 있다.

두가지 상황을 처리할 필요가 있다. 

1)트럭의 무게 합이 weight를 넘었을 때
2)트럭의 무게 합이 weight를 넘지 않았을 때

다리 길이 100
weight 50

트럭 [10,10,10,10,10,10,10,10,10,10]

이렇게 있다고 해보자.

다리 위에는 5개까지 올라갈 수 있다. 트럭들이 다리를 모두 건널 때까지 기다려야 한다. 끝에 다다랐을 때, 맨 앞에 트럭이 빠지고 새 트럭이 뒤에 들어올 수 있다. 코드로 구현하면 아래와 같다.

```java
for(int truck :truck_weights){
            while((totalWeights+truck-bridge.peek())>weight){----(1)
                totalWeights -=bridge.remove(); ---(2)
                bridge.add(0); ----(3)
                timeElapsed++;---(4)
            }
```      

(1)은새로운 트럭을 더했을 때 트럭들의 총 무게가 weigth를 넘기는지 아닌지 체크한다.다. (2)에서 다리의 맨 앞에 있는 것을 빼준다. 여기서는 미리 채워놓았던 0이다. (3)에서는 뒤에 0을 채워준다. (4)에서는 시간이 1초 지났다. 이러한 로직을 통해서 다리 위 트럭들이 한칸씩 이동한 결과를 만들어낼 수 있다.

트럭의 총 무게가 weight를 넘지 않은 상황도 처리해줘야 한다. 위와 로직은 동일하다.
```java
totalWeights -=bridge.remove(); ---(1)
            totalWeights +=truck; ---(2)
            bridge.add(truck); ---(3)
            timeElapsed++; ---(4)
        }
```

(1)에서 다리 맨 앞에 있는 것을 빼준다. 0일 수도 있고, 트럭일 수도 있다. 트럭이라면 총 무게에서 그 트럭의 무게를 빼준다. (2)와 (3)는 새로운 트럭을 다리 위에 올리는 로직이다. 이 작업을 한번 할 떄마다 (4)를 통해 1초씩 늘린다.
```java
  return timeElapsed+bridge_length;
```

결과물은 지금까지 소요된 시간에 다리 길이를 추가한 것을 반환한다. 이 부분이 중요하다. 트럭이 (1)번 부대, (2)번 부대로 나뉘어서 갈 때 1번부대는 while 로직을 통해서 끝까지 갈 떄까지 걸리는 시간을 계산했다. 2번부대는 다리를 지나는 시간을 로직에 따로 추가해줘야 한다. 
