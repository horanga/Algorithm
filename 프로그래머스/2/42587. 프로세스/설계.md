설계
=============
1.자료구조는 우선순위 큐를 썼다. 우선순위큐는 넣은 숫자를 오름차순으로 정렬하는 특성이 있다. comparator를 조정해주면 되는데, Collection.reversorder()를 사용하면 숫자를 역순(내림차순)으로 정렬한다
(큐이기 때문에 가장 앞에 있는 자료가 먼저 나온다.)

2.문제 지문에는 'priorities의 원소는 우선순위를 나타내며 숫자가 클 수록 우선순위가 높습니다.'라는 설명이 있었다. 즉, 숫자가 높을수록 우선순위가 높고, 숫자가 높은 작업이 먼저 처리돼야 한다. 


```java
 PriorityQueue<Integer> queue = new PriorityQueue<>(Collections.reverseOrder());
        int completedJobCount = 0;


        for (int i : priorities) {
            queue.offer(i);
        }
```

3.priroities의 요소들을 queue에 넣어주면, 높은 숫자대로 내림차순으로 자료구조에 들어간다. 


4.이제 자료구조에서 자료를 빼주면 된다. 그럼, 우선순위가 높은 작업부터 먼저 나온다. 그전에 먼저, 
priorites를 순회하면서 큐에 맨 앞에 있는 자료(우선순위가 제일 높은)가 원래는 어느 인덱스에 위치해 있었는지를 찾아주었다. 

만약, 원소를 찾았다면 큐에서 빼주고 completedJobCount의 숫자를 증가시켰다. 

{1, 3, 3, 5, 2}라는 배열이 있고, location의 값을 '2'라고 해보자. 
queue에 들어가면 {5, 3, 3, 2, 1}순으로 들어간다.

```java
while (!queue.isEmpty()) {
            for (int i = 0; i < priorities.length; i++) {
                if (queue.peek() == priorities[i]) {
                    queue.poll();
                    completedJobCount++;

                    if (location == i) {
                        return completedJobCount;
                    }
                }
            }
        }
```

1)처음 배열을 순회할 때 queue.peek()은 5고, 원래 배열에서 인덱스는 3이다. 큐에서 5를 빼면 0이었던  completedJobCount이 1증가한다. 즉, 첫번째로 처리한 작업이라는 뜻이다.

2)그 다음 if구문에서 location(2)와 index(i)가 동일한지 확인한다. 아쉽게도, 우리가 알고 싶었던 location과 다르다. 이제 다시 while문을 반복해서, location과 index가 동일할 때까지 작업을 반복한다.

3)그 다음 while 루프에서도 location과 index가 다르기 때문에, 반복을 한번 더 한다. 이 방식을 통하면 우선순위가 같지만 location이 다른 상황도 무사히 걸러낼 수 있다. 

우선순위 큐의 작동 방식을 보면, 우선순위가 높은순서대로 배열에 정렬된다.(Collection.reverseorder()을 해줬기 때문) 

대신, priroities을 순회할 때 순서는 유지된다. 즉, 같은 숫자가 있다면 인덱스 순서대로 저장된다는 것이다. 설명이 조금 복잡하다. 실제 예시로 다시 살펴보자.

처음에 5를 queue에서 뺐으면, {3, 3, 2, 1}가 남아있게 된다. 이제 다시 while 루프를 돌아보자. queue.peek을 했을 때 3이 나오고, priorities[i]에서 i는 1이 된다. 이 작업은 우리가 찾던 위치의 그 작업이 아니다.

왜냐하면, {1, 3, 3, 5, 2} 이 배열에서 queue에 들어갈 때 처음 1->3->3->5->2 순서대로 들어가지만, 그 안에서 숫자가 오름차순/내림차순으로 정렬될 뿐이기 때문이다. 5가 맨 앞으로 오고 1이 뒤로 가지만 3과 3의 상대적인 위치는 달라지지 않는다.

그러므로, while루프를 한번 더 돌아야만 우리가 찾던 location(2)의 작업을 만날 수 있게 된다.

