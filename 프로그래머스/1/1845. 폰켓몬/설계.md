설계
=============

1.자료구조로는 Set을 사용했다. Set은 중복을 허용하지 않는 특성이 있다. 특히 ``if(set.add(A))``와 같이 사용할 때, 만약 set에 A라는 요소가 이미 들어가 있다면 'false'를 그렇지 않다면 'true'를 반환하는 덕분에 더 유용하게 이용할 수 있다.

2.문제의 요구 사항은 '다른 종류의 폰켓몬을 가져갈 때, 최대한 많은 종류를 가져가는 것'이다. 폰켓몬의 종류번호가 들어가있는 nums 배열을 순회하면서 이미 set에 들어가 있는 것은 넘기고, 들어가 지있지 않은 경우 set에 넣으면서 카운트를 해줬다. 덕분에 1번 폰켓몬을 가져갔으면(set에 넣으면) 그 다음부터 1번 폰켓몬을 만났을 때 바로 넘겨버릴 수 있다.

```java
if(uniquePokemons.add(nums[i])){
answer++;
} 
```

3.폰켓몬은 총 n/2만큼만 가져갈 수 있다고 지문에 적혀있다. 그러니, answer(가져가는 폰켓몬 종류 수)가 n/2가 됐을 때부터는 더이상 nums를 순회하지 않아도 된다.

```java
final int MAX_UNIQUE = nums.length / 2;
...
for(int i =0; i<nums.length&& answer < MAX_UNIQUE; i++)
```
